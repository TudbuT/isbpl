native alen
native aget
native aput
native anew
native _array
func __array {
    "NotImplemented" "Not implemented" throw
}

native _char
native _int
native _file
native _float
native _long
native _double

func __char {
    _char
}
func __int {
    _int
}
func __file {
    _file
}
native __float
func __long {
    _long
}
native __double

native ischar
native isint
native isfloat
native islong
native isdouble

# "call a dynamically computed function" pop
# "Please keep in mind that this will throw a native error if" pop
# "called incorrectly - this means wrong layer parameter will" pop
# "instantly crash the program." pop
native _layer_call
func call {
    0 _layer_call
}
native include
native putchar
native read
native flength
native write
native type
native mktype
native typename
native istype
native settype
# "try and catch are keywords, not functions" pop
native throw
native exit
# "storelength" pop
native stlen

native eq
native gt
native lt
native not
native or
native and
native +
native -
native /
native *
native **
native %
native ^

native dup
native pop
native swap

func ++ { 1 + }
func -- { 1 - }

# "this looks so wrong" pop
func ( { }
func ) { }
func # { }

"char" mktype =TYPE_CHAR
"int" mktype =TYPE_INT
"file" mktype =TYPE_FILE
"float" mktype =TYPE_FLOAT
"long" mktype =TYPE_LONG
"double" mktype =TYPE_DOUBLE
"array" mktype =TYPE_ARRAY

"string" mktype =TYPE_STRING
func _string {
    =object

    object ischar if {
        0 _char 1 anew =object
    }
    object isint if {
        itos =object
    }
    object isfloat if {
        ftoi =object
    }
    object islong if {
        ltoi =object
    }
    object isdouble if {
        dtoi =object
    }
    
    object
}
func __string {
    _string
}
func isstring {
    isarray
}

func itos {
    ntos
}

func ltos {
    ntos
}

func ftos {
    ntos
}

func dtos {
    ntos
}

# "Number to string" pop
func ntos {
    "" =s
    =n

    n 0 lt dup if { n neg =n 1 =negative } =negative
    n type =thetype

    while { n 1 lt not } {
        n ( n 10 % dup =x ) - =n
        s ( n '0' + _char ) strconcat =s
    }
    1 =steps
    while { n 0 eq not } {
        n ( n ( 1 ( steps dup 10 * =steps ) / ) % dup =x ) - =n
        s ( x '0' + _char ) strconcat =s
    }


    s
}

# "Copy array" pop
func acopy {
    # "bind args" pop
    =len
    =idx2
    =idx1
    =arr2
    =arr1

    1 neg =i
    while { ( i 1 + =i ) ( i len lt ) } {
        arr2 i idx2 + ( arr1 i idx1 + aget ) aput
    }
}

func strconcat {
    # "bind args" pop
    _string =str2
    _string =str1
    
    0 _char str1 alen str2 alen + anew =str
    
    str1 str 0 0         str1 alen acopy
    str2 str 0 str1 alen str2 alen acopy

    str
}

func strsplit {
    # "bind args" pop
    _string =splitter
    _string =str

    1 neg =i
    "" 0 anew =sequences
    "" =sequence
    while { ( i 1 + =i ) ( i str alen lt ) } {
        str i aget =chr
        splitter 0 aget =spl
        sequence chr strconcat =sequence
        1 neg =j
        while { ( j 1 + =j ) ( chr spl eq ) } {
            j splitter alen eq if {
                sequences =oldsq
                "" ( sequences alen dup =seq 1 + ) anew =sequences
                oldsq sequences 0 0 oldsq alen acopy
                sequences seq sequence aput
                "" =sequence
                2 stop
            }
            str i j + aget dup =chr
            splitter j aget dup =spl
        }
    }

    sequences
}

func strjoin {
    # "bind args" pop
    _string =joiner
    _array =arr

    1 neg =i
    "" =s
    while { ( i 1 + =i ) ( i arr alen lt ) } {
        s arr i aget joiner strconcat strconcat =s
    }

    s
}

func strsub {
    # "bind args" pop
    _int =pos2
    _int =pos1
    _string =string

    pos2 pos1 - =length

    ( o _char length anew dup ) string swap pos1 0 length acopy
}

func puts {
    _string =str
    1 neg =i
    while { ( i 1 + =i ) ( i str alen lt ) } {
        str i aget putchar
    }
}

func anewput {
    def size =size
    def arr size anew =arr
    
    def i 0 =i
    while i size lt {
        arr swap i swap aput
        i 1 + =i
    }

    arr areverse
}

func areverse {
    def arr =arr
    def new arr alen anew =new

    def i arr alen 1 - =i
    def j 0 =j
    while i 0 lt not {
        new j arr i aget aput
        j 1 + =j
        i 1 - =i
    }

    new
}

func inc {
    def varname =varname
    ( varname 1 _layer_call ) # "Get var" pop
        1 + # "Increment" pop
        ( "=" varname strconcat 1 _layer_call ) # "Store var" pop
}

func dec {
    def varname =varname
    ( varname 1 _layer_call ) # "Get var" pop
        1 - # "Decrement" pop
        ( "=" varname strconcat 1 _layer_call ) # "Store var" pop
}

