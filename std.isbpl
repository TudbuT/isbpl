native dup
native pop
native swap

func # { pop }

native alen
native aget
native aput
native anew
native _array

native _char
native _byte
native _int
native _float
native _long
native _double

native ischar
native isbyte
native isint
native isfloat
native islong
native isdouble
native isarray

"call a dynamically computed function" #
"Please keep in mind that this will throw a native error if" #
"called incorrectly - this means wrong layer parameter will" #
"instantly crash the program." #
native _layer_call
func call {
    1 _layer_call
}
"This returns the last word as a string, from an index." #
"index has to be <16, index 0 is this call" #
native _last_word
native include
native putchar
native mktype
native getos
native typename
native gettype
native settype
"try and do are keywords, not functions" #
native throw
native exit

native eq
native gt
native lt
native not
native neg
native or
native and
native +
native -
native /
native *
native **
native %
native ^

func ++ { 1 + }
func -- { 1 - }

"this looks so wrong" #
func ( { }
func ) { }
func ; { }

"int must be registered first." #
def TYPE_INT "int" mktype =TYPE_INT
def TYPE_CHAR "char" mktype =TYPE_CHAR
def TYPE_BYTE "byte" mktype =TYPE_BYTE
def TYPE_FLOAT "float" mktype =TYPE_FLOAT
def TYPE_LONG "long" mktype =TYPE_LONG
def TYPE_DOUBLE "double" mktype =TYPE_DOUBLE
def TYPE_ARRAY "array" mktype =TYPE_ARRAY

def TYPE_STRING "string" mktype =TYPE_STRING
func _string {
    def object =object

    object ischar if {
        1 anew =object
        object TYPE_STRING settype
    }
    object isbyte if {
        itos =object
    }
    object isint if {
        itos =object
    }
    object isfloat if {
        ftoi =object
    }
    object islong if {
        ltoi =object
    }
    object isdouble if {
        dtoi =object
    }

    object isarray if {
        object TYPE_STRING settype =object
    }
    object isstring not if {
        "IncompatibleTypes" "Incompatible types: " object gettype typename " - string" strconcat strconcat throw
    }
    
    object
}
func isstring {
    gettype typename "string" eq
}

func itos {
    ntos
}

func ltos {
    ntos
}

func ftos {
    ntos
}

func dtos {
    ntos
}

"Number to string" #
func ntos {
    def s "" =s
    def n =n

    def negative n 0 lt dup if { n neg =n 1 =negative } =negative
    def thetype n gettype =thetype

    while { n 1 lt not } {
        n ( n 10 % dup =x ) - =n
        s ( n '0' + _char ) strconcat =s
    }
    def steps 1 =steps
    while { n 0 eq not } {
        n ( n ( 1 ( steps dup 10 * =steps ) / ) % dup =x ) - =n
        s ( x '0' + _char ) strconcat =s
    }

    negative if {
        n neg =n
    }

    s
}

func ston {
    def s =s "bind string" #
    def n 0 =n "the number to return" #
    def negative def idx s 0 aget '-' eq dup =idx =negative

    while { idx s alen lt } {
        def chr s idx aget =chr
        n ( chr ( 10 ( s alen idx - 1 - ) ** ) + =n
        idx inc
    }

    n
}

"Copy array" #
func acopy {
    "bind args" #
    def len =len
    def idx2 =idx2
    def idx1 =idx1
    def arr2 =arr2
    def arr1 =arr1

    def i 1 neg =i
    while { ( i 1 + =i ) ( i len lt ) } {
        arr2 i idx2 + ( arr1 i idx1 + aget ) aput
    }
}

func strconcat {
    "bind args" #
    def str2 _string =str2
    def str1 _string =str1

    def str 0 _char str1 alen str2 alen + anew =str

    str1 str 0 0         str1 alen acopy
    str2 str 0 str1 alen str2 alen acopy

    str
}

func strsplit {
    "bind args" #
    def splitter _string =splitter
    def str _string =str

    1 neg =i
    def sequences "" 0 anew =sequences
    def sequence "" =sequence
    while { ( i 1 + =i ) ( i str alen lt ) } {
        def chr str i aget =chr
        def spl splitter 0 aget =spl
        sequence chr strconcat =sequence
        1 neg =j
        while { ( j 1 + =j ) ( chr spl eq ) } {
            j splitter alen eq if {
                def oldsq sequences =oldsq
                "" ( sequences alen dup =seq 1 + ) anew =sequences
                oldsq sequences 0 0 oldsq alen acopy
                sequences seq sequence aput
                "" =sequence
                2 stop
            }
            str i j + aget dup =chr
            splitter j aget dup =spl
        }
    }

    sequences
}

func strjoin {
    "bind args" #
    def joiner _string =joiner
    def arr _array =arr

    1 neg =i
    def s "" =s
    while { ( i 1 + =i ) ( i arr alen lt ) } {
        s arr i aget joiner strconcat strconcat =s
    }

    s
}

func strsub {
    "bind args" #
    def pos2 _int =pos2
    def pos1 _int =pos1
    def string _string =string

    pos2 pos1 - =length

    ( o _char length anew dup ) string swap pos1 0 length acopy
}

func puts {
    def str _array =str
    def i 1 neg =i
    while { ( i 1 + =i ) ( i str alen lt ) } {
        str i aget putchar
    }
}

func anewput {
    def size =size
    def arr size anew =arr

    def i 0 =i
    while { i size lt } {
        arr swap i swap aput
        i 1 + =i
    }

    arr areverse
}

func areverse {
    def arr =arr
    def new arr alen anew =new

    def i arr alen 1 - =i
    def j 0 =j
    while { i 0 lt not } {
        new j arr i aget aput
        j 1 + =j
        i 1 - =i
    }

    new
}

func strcontains {
    def check =check "bind check" #
    def s =s "bind string" #

    def found 0 =found
    def counter 0 =counter
    def i 0 =i
    def j 0 =j
    while { i s alen lt } {
        s i aget check j aget eq dup if {
            counter inc
        }
        not if {
            0 =counter
        }
        counter check alen eq if {
            3 stop
        }
        i inc
    }
    counter check alen eq
}

"These functions are magic, they use natives to get recent words and modify the" #
"variables, do not touch them unless you know exactly what you're doing!" #
func inc {
    def varname 4 _last_word =varname
    pop
    ( varname 1 _layer_call ) "Get var" #
        1 + "Increment" #
        ( "=" varname strconcat 1 _layer_call ) "Store var" #
}
func dec {
    def varname 4 _last_word =varname
    pop
    ( varname 1 _layer_call ) "Get var" #
        1 - "Decrement" #
        ( "=" varname strconcat 1 _layer_call ) "Store var" #
}

func random {
    "file.isbpl" include
    getos strlowercase dup ( "linux" strcontains ) swap ( "macos" strcontains ) or dup if {
        "/dev/urandom" _file 0 1 read
    }
    not if {
        "__windows_radom" call
    }
}

func strlowercase {
    def s =s "bind string" #
    def i 0 =i
    while { i s alen lt } {
        def char s i aget =char
        char 64 gt char 91 lt and if {
            s i char 32 + aput
        }
        i inc
    }
    s
}

func struppercase {
    def s =s "bind string" #
    def i 0 =i
    while { i s alen lt } {
        def char s i aget =char
        char 89 gt char 123 lt and if {
            s i char 32 - aput
        }
        i inc
    }
    s
}
